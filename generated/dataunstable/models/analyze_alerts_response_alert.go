// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AnalyzeAlertsResponseAlert Alert represents a logical alert with its lifecycle and history.
// This type is specific to analytical access patterns in this package.
// Contains complete alert metadata, timing, and historical events.
//
// swagger:model AnalyzeAlertsResponseAlert
type AnalyzeAlertsResponseAlert struct {

	// Unique identifier for this alert instance
	AlertID string `json:"alert_id,omitempty"`

	// When this alert resolved (if it has resolved)
	// Format: date-time
	EndTime strfmt.DateTime `json:"end_time,omitempty"`

	// Whether this alert is currently muted
	IsMuted bool `json:"is_muted,omitempty"`

	// Number of monitor labels that matched the filter criteria (if monitor_labels filter was provided)
	MonitorLabelMatchCount int32 `json:"monitor_label_match_count,omitempty"`

	// Labels attached to the monitor that generated this alert
	MonitorLabels []*DataunstableAnalyzeAlertsResponseLabel `json:"monitor_labels"`

	// Human-readable name of the monitor
	MonitorName string `json:"monitor_name,omitempty"`

	// Slug of the monitor that generated this alert
	MonitorSlug string `json:"monitor_slug,omitempty"`

	// Historical record of mute/unmute actions
	MuteHistory []*AnalyzeAlertsResponseMuteActionHistoryEntry `json:"mute_history"`

	// Human-readable name of the notification policy
	NotificationPolicyName string `json:"notification_policy_name,omitempty"`

	// Slug of the notification policy handling this alert
	NotificationPolicySlug string `json:"notification_policy_slug,omitempty"`

	// Historical record of notification attempts
	NotifierHistory []*AnalyzeAlertsResponseNotifierHistoryEntry `json:"notifier_history"`

	// Ownership context for the monitor
	OwnershipContext *AnalyzeAlertsResponseOwnershipContext `json:"ownership_context,omitempty"`

	// Historical record of severity changes throughout the alert lifecycle
	SeverityHistory []*AnalyzeAlertsResponseSeverityChangeHistoryEntry `json:"severity_history"`

	// If configured, key-value pairs (labels, from telemetry) that semantically characterize the alert further.
	Signal []*DataunstableAnalyzeAlertsResponseLabel `json:"signal"`

	// Number of signals that matched the filter criteria (if signals filter was provided)
	SignalMatchCount int32 `json:"signal_match_count,omitempty"`

	// Hash of signals for grouping alerts with identical signal combinations.
	SignalsHash string `json:"signals_hash,omitempty"`

	// SLO metadata if this alert is from an SLO-generated monitor
	SloMetadata *AnalyzeAlertsResponseSloMetadata `json:"slo_metadata,omitempty"`

	// When this alert first triggered
	// Format: date-time
	StartTime strfmt.DateTime `json:"start_time,omitempty"`

	// Tenant identifier for the alert
	TenantID string `json:"tenant_id,omitempty"`
}

// Validate validates this analyze alerts response alert
func (m *AnalyzeAlertsResponseAlert) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEndTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMonitorLabels(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMuteHistory(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNotifierHistory(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOwnershipContext(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSeverityHistory(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSignal(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSloMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartTime(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AnalyzeAlertsResponseAlert) validateEndTime(formats strfmt.Registry) error {
	if swag.IsZero(m.EndTime) { // not required
		return nil
	}

	if err := validate.FormatOf("end_time", "body", "date-time", m.EndTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *AnalyzeAlertsResponseAlert) validateMonitorLabels(formats strfmt.Registry) error {
	if swag.IsZero(m.MonitorLabels) { // not required
		return nil
	}

	for i := 0; i < len(m.MonitorLabels); i++ {
		if swag.IsZero(m.MonitorLabels[i]) { // not required
			continue
		}

		if m.MonitorLabels[i] != nil {
			if err := m.MonitorLabels[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("monitor_labels" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("monitor_labels" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *AnalyzeAlertsResponseAlert) validateMuteHistory(formats strfmt.Registry) error {
	if swag.IsZero(m.MuteHistory) { // not required
		return nil
	}

	for i := 0; i < len(m.MuteHistory); i++ {
		if swag.IsZero(m.MuteHistory[i]) { // not required
			continue
		}

		if m.MuteHistory[i] != nil {
			if err := m.MuteHistory[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("mute_history" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("mute_history" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *AnalyzeAlertsResponseAlert) validateNotifierHistory(formats strfmt.Registry) error {
	if swag.IsZero(m.NotifierHistory) { // not required
		return nil
	}

	for i := 0; i < len(m.NotifierHistory); i++ {
		if swag.IsZero(m.NotifierHistory[i]) { // not required
			continue
		}

		if m.NotifierHistory[i] != nil {
			if err := m.NotifierHistory[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("notifier_history" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("notifier_history" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *AnalyzeAlertsResponseAlert) validateOwnershipContext(formats strfmt.Registry) error {
	if swag.IsZero(m.OwnershipContext) { // not required
		return nil
	}

	if m.OwnershipContext != nil {
		if err := m.OwnershipContext.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ownership_context")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ownership_context")
			}
			return err
		}
	}

	return nil
}

func (m *AnalyzeAlertsResponseAlert) validateSeverityHistory(formats strfmt.Registry) error {
	if swag.IsZero(m.SeverityHistory) { // not required
		return nil
	}

	for i := 0; i < len(m.SeverityHistory); i++ {
		if swag.IsZero(m.SeverityHistory[i]) { // not required
			continue
		}

		if m.SeverityHistory[i] != nil {
			if err := m.SeverityHistory[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("severity_history" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("severity_history" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *AnalyzeAlertsResponseAlert) validateSignal(formats strfmt.Registry) error {
	if swag.IsZero(m.Signal) { // not required
		return nil
	}

	for i := 0; i < len(m.Signal); i++ {
		if swag.IsZero(m.Signal[i]) { // not required
			continue
		}

		if m.Signal[i] != nil {
			if err := m.Signal[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("signal" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("signal" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *AnalyzeAlertsResponseAlert) validateSloMetadata(formats strfmt.Registry) error {
	if swag.IsZero(m.SloMetadata) { // not required
		return nil
	}

	if m.SloMetadata != nil {
		if err := m.SloMetadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("slo_metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("slo_metadata")
			}
			return err
		}
	}

	return nil
}

func (m *AnalyzeAlertsResponseAlert) validateStartTime(formats strfmt.Registry) error {
	if swag.IsZero(m.StartTime) { // not required
		return nil
	}

	if err := validate.FormatOf("start_time", "body", "date-time", m.StartTime.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this analyze alerts response alert based on the context it is used
func (m *AnalyzeAlertsResponseAlert) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateMonitorLabels(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMuteHistory(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNotifierHistory(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOwnershipContext(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSeverityHistory(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSignal(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSloMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AnalyzeAlertsResponseAlert) contextValidateMonitorLabels(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.MonitorLabels); i++ {

		if m.MonitorLabels[i] != nil {

			if swag.IsZero(m.MonitorLabels[i]) { // not required
				return nil
			}

			if err := m.MonitorLabels[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("monitor_labels" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("monitor_labels" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *AnalyzeAlertsResponseAlert) contextValidateMuteHistory(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.MuteHistory); i++ {

		if m.MuteHistory[i] != nil {

			if swag.IsZero(m.MuteHistory[i]) { // not required
				return nil
			}

			if err := m.MuteHistory[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("mute_history" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("mute_history" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *AnalyzeAlertsResponseAlert) contextValidateNotifierHistory(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NotifierHistory); i++ {

		if m.NotifierHistory[i] != nil {

			if swag.IsZero(m.NotifierHistory[i]) { // not required
				return nil
			}

			if err := m.NotifierHistory[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("notifier_history" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("notifier_history" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *AnalyzeAlertsResponseAlert) contextValidateOwnershipContext(ctx context.Context, formats strfmt.Registry) error {

	if m.OwnershipContext != nil {

		if swag.IsZero(m.OwnershipContext) { // not required
			return nil
		}

		if err := m.OwnershipContext.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ownership_context")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ownership_context")
			}
			return err
		}
	}

	return nil
}

func (m *AnalyzeAlertsResponseAlert) contextValidateSeverityHistory(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SeverityHistory); i++ {

		if m.SeverityHistory[i] != nil {

			if swag.IsZero(m.SeverityHistory[i]) { // not required
				return nil
			}

			if err := m.SeverityHistory[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("severity_history" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("severity_history" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *AnalyzeAlertsResponseAlert) contextValidateSignal(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Signal); i++ {

		if m.Signal[i] != nil {

			if swag.IsZero(m.Signal[i]) { // not required
				return nil
			}

			if err := m.Signal[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("signal" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("signal" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *AnalyzeAlertsResponseAlert) contextValidateSloMetadata(ctx context.Context, formats strfmt.Registry) error {

	if m.SloMetadata != nil {

		if swag.IsZero(m.SloMetadata) { // not required
			return nil
		}

		if err := m.SloMetadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("slo_metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("slo_metadata")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AnalyzeAlertsResponseAlert) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AnalyzeAlertsResponseAlert) UnmarshalBinary(b []byte) error {
	var res AnalyzeAlertsResponseAlert
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
